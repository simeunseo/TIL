| 작성일     | 플랫폼       | 레벨 | 시도 | 키워드      |
| ---------- | ------------ | ---- | ---- | ----------- |
| 2024/05/26 | 프로그래머스 | Lv4  | 0    | `이진 탐색` |

<details>
<summary style="font-size: 24px; font-weight:600">
문제
</summary>
<div markdown="1">

### **문제 설명**

출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다.

예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.

| 제거한 바위의 위치 | 각 바위 사이의 거리 | 거리의 최솟값 |
| ------------------ | ------------------- | ------------- |
| [21, 17]           | [2, 9, 3, 11]       | 2             |
| [2, 21]            | [11, 3, 3, 8]       | 3             |
| [2, 11]            | [14, 3, 4, 4]       | 3             |
| [11, 21]           | [2, 12, 3, 8]       | 2             |
| [2, 14]            | [11, 6, 4, 4]       | 4             |

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
- 바위는 1개 이상 50,000개 이하가 있습니다.
- n 은 1 이상 `바위의 개수` 이하입니다.

### 입출력 예

| distance | rocks               | n   | return |
| -------- | ------------------- | --- | ------ |
| 25       | [2, 14, 11, 21, 17] | 2   | 4      |

### 입출력 예 설명

문제에 나온 예와 같습니다.

</div>
</details>

# 생각 과정

먼저 탐색 범위를 0부터 distance까지로 해야겠다는 생각까지는 했는데, 어떤 값을 찾으려 할 것이나? 라는 질문에 대한 답을 제대로 정하지 못한 것 같다. 노트에 좌표를 그려놓고, mid의 좌측과 우측 중에서 결정할 때 무엇을 기준으로 결정해야할지를 생각해내지 못했다.

정답을 찾아보니, mid의 의미를 `제거할 간격의 최댓값` 이라고 놓으면 되는 것이었다.

예를들어 mid = 12라면, 출발점, 도착점, 돌 사이의 간격들 배열을 순회하며 하나씩 돌을 제거하고 거리를 측정한다. (acc+=dist) 그러다가 거리가 mid가 넘어가면 조건에 위배되므로 acc를 0으로 초기화하여 다시 거리를 측정한다. 이런식으로 제거되는 돌의 갯수를 세어 n과 비교해준 뒤 제거된 수가 n보다 크면 right값을 mid 아래로 옮겨 더 작은 범위에서 탐색한다.

(사실 이 로직도 도출해내기 정말 어려운 것 같다..)

이진 탐색을 활용하려면

**1. 탐색 범위 정하기**

**2. mid가 의미하는 바**

**3. 정답 도출 조건**

이것들을 정하는 것이 매우 중요하다는 걸 깨달았다.

### 정답 코드

```jsx
function solution(distance, rocks, n) {
  rocks.push(0);
  rocks.push(distance);
  rocks.sort((a, b) => a - b);
  const rocksDist = [];
  for (let i = 1; i < rocks.length; i++) {
    rocksDist.push(rocks[i] - rocks[i - 1]);
  }

  let left = 0;
  let right = distance;
  let ans = 0;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    let remove = 0;
    let acc = 0;
    for (const dist of rocksDist) {
      if (acc + dist < mid) {
        acc += dist;
        remove++;
      } else {
        acc = 0;
      }
    }

    if (remove > n) {
      right = mid - 1;
    } else {
      left = mid + 1;
      ans = mid;
    }
  }
  return ans;
}
```
