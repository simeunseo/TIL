| 작성일     | 플랫폼       | 레벨 | 시도 | 키워드      |
| ---------- | ------------ | ---- | ---- | ----------- |
| 2024/05/26 | 프로그래머스 | Lv3  | 0    | `이진 탐색` |

<details>
<summary style="font-size: 24px; font-weight:600">
문제
</summary>
<div markdown="1">

### **문제 설명**

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.

### 입출력 예

| n   | times   | return |
| --- | ------- | ------ |
| 6   | [7, 10] | 28     |

### 입출력 예 설명

가장 첫 두 사람은 바로 심사를 받으러 갑니다.

7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.

10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.

14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.

20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

</div>
</details>

# 생각 과정

카테고리가 이진 탐색이었지만 일단 이것에 얽매이지 않고 생각했을 때, queue 자료구조를 이용하면 어떨까 하는 생각이 들었다. times 배열에 들어있는 수만큼 queue를 만들고(심사관), n을 올려가며 queue에 넣으면서 각 queue에 대한 소요시간을 측정하고 조건문으로 queue에서 빼내고 새로운 n을 넣는 식이다. 그런데 제한사항을 보니 심사관이 최대 100,000명이어서 이 설계는 무리라는 생각이 들었다.

이분 탐색이라 하면 특정 값의 위치를 찾아내는 것인데, ‘위치’에 매몰되다보니 이 문제에 어떻게 적용해야할지 떠오르지 않아 해답을 먼저 찾아봤다.

### 정답 코드

```jsx
function solution(n, times) {
  let left = 1;
  let right = Math.max(...times) * n;
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    let people = times.reduce(
      (acc, time) => (acc += Math.floor(mid / time)),
      0
    );
    if (people < n) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return left;
}
```

핵심은 특정 값의 위치를 찾아낸다는 개념을, ‘최소 시간’을 찾아내는데 사용하는 것이었다. 코드를 보면 기본 이진탐색 코드와 크게 다른 것이 없다. 중요한 것은, 주어진 times로 부터 심사에 소요되는 최소 시간과 최대 시간(1과 times최댓값 \* n)을 범위로 잡고, 이 안에서 이진 탐색을 하면서 어떤 값에서 6명을 심사하게 되는지를 찾는 것이다.

특정 시간 동안에 몇 명을 심사할 수 있는 지는 다음과 같이 구할 수 있었다.

`let people = times.reduce((acc, time)=> acc+= Math.floor(mid/time), 0)`

비어있는 줄이 있다면 그곳으로 가서 최소한의 시간을 쓴다는게 굉장히 복잡하게 느껴졌는데, 단순히 mid(현재 기준이 될 소요시간)를 time으로 나눈 값을 더해주면 되는 것이었다.
